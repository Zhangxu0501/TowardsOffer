第8题：二分查找
当数组有序的时候的查找，我们要首先想到二分查找来解决问题。
对递归的过程要清醒，递归的开头要先处理边界问题。对于每种情况要分别return就好了。。。不可出现那种笑话。

第9题：递归
递归优缺点：代码简单方便，易实现，时间空间复杂度大，因为自身调用自身，需要压栈，保存临时变量等。
而且有的递归会重复计算子问题的重叠部分，如斐波那契数列。

第10题：二进制
五种二进制运算
与&
或|
亦或^
左移<<	左边n位丢弃，右边补0，可视为成2
右移>>	如果原来数字正数，用0补左边，如果是负数，用1补左边
与可以判断两个二进制数各个位数是否都是1，或看是否有1，亦或看是否全部相同。



第三章：高质量代码
代码的完整性，写代码之前便要考虑好可能的输入，并且想好测试样例，包括功能测试、边界测试、负面测试。

3.4代码的鲁棒性&防御性编程
代码的鲁棒性是指程序运行的稳定性，通常要验证用户的输入是否符合要求，对于面试来说，我们要写几个函数，
考虑的就是函数的参数是否符合，如字符串是"",指针为null，数组长度为0，文件不存在，服务器无法访问等等情况，我们把这些因素考虑全面，就能学出高鲁棒性的代码。

#重要！！！！！
#防御性编程很重要，首先要检查各种输入是否是正确的输入，防止没有处理空指针导致的各种异常，以及各种边界条件

- problem24的递归终结条件需要考虑的很清楚，这也是递归的关键所在，什么时候到达递归的出口一定要想清楚，不然没法写


#Partation的思想
Partation函数可以找到第k大的位置，包括中位数，等，有效的利用这个函数，可以很好地解决许多问题。而不是通过复杂的排序来找到这个数字。
    public int partation(int [] array,int start,int end)
	{
		int temp=array[start];
		int i=start;int j=end+1;
		while(true)
		{
			while(temp>array[++i]);
			while(temp<array[--j]);
			if(i>=j)
				break;
			swap(array,i,j);
		}
		swap(array,j,start);
		return j;
	}
